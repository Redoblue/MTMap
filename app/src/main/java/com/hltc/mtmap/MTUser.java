package com.hltc.mtmap;

import java.util.List;

import com.hltc.mtmap.orm.DaoSession;

import de.greenrobot.dao.DaoException;

import com.hltc.mtmap.orm.MTCommentDao;
import com.hltc.mtmap.orm.MTFavouriteDao;
import com.hltc.mtmap.orm.MTGrainDao;
import com.hltc.mtmap.orm.MTPhotoDao;
import com.hltc.mtmap.orm.MTUserDao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END

/**
 * Entity mapped to table MTUSER.
 */
public class MTUser {

    private long userId;
    private String nickName;
    private String createTime;
    private String phone;
    private String portrait;
    private String coverImg;
    private String signature;
    private String remark;
    private String firstCharacter;

    /**
     * Used to resolve relations
     */
    private transient DaoSession daoSession;

    /**
     * Used for active entity operations.
     */
    private transient MTUserDao myDao;

    private List<MTComment> comments2User;
    private List<MTFavourite> favourite2User;
    private List<MTGrain> grains2User;
    private List<MTPhoto> photo2User;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public MTUser() {
    }

    public MTUser(long userId) {
        this.userId = userId;
    }

    public MTUser(long userId, String nickName, String createTime, String phone, String portrait, String coverImg, String signature, String remark, String firstCharacter) {
        this.userId = userId;
        this.nickName = nickName;
        this.createTime = createTime;
        this.phone = phone;
        this.portrait = portrait;
        this.coverImg = coverImg;
        this.signature = signature;
        this.remark = remark;
        this.firstCharacter = firstCharacter;
    }

    /**
     * called by internal mechanisms, do not call yourself.
     */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMTUserDao() : null;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public String getCreateTime() {
        return createTime;
    }

    public void setCreateTime(String createTime) {
        this.createTime = createTime;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getPortrait() {
        return portrait;
    }

    public void setPortrait(String portrait) {
        this.portrait = portrait;
    }

    public String getCoverImg() {
        return coverImg;
    }

    public void setCoverImg(String coverImg) {
        this.coverImg = coverImg;
    }

    public String getSignature() {
        return signature;
    }

    public void setSignature(String signature) {
        this.signature = signature;
    }

    public String getRemark() {
        return remark;
    }

    public void setRemark(String remark) {
        this.remark = remark;
    }

    public String getFirstCharacter() {
        return firstCharacter;
    }

    public void setFirstCharacter(String firstCharacter) {
        this.firstCharacter = firstCharacter;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTComment> getComments2User() {
        if (comments2User == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTCommentDao targetDao = daoSession.getMTCommentDao();
            List<MTComment> comments2UserNew = targetDao._queryMTUser_Comments2User(userId);
            synchronized (this) {
                if (comments2User == null) {
                    comments2User = comments2UserNew;
                }
            }
        }
        return comments2User;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetComments2User() {
        comments2User = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTFavourite> getFavourite2User() {
        if (favourite2User == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTFavouriteDao targetDao = daoSession.getMTFavouriteDao();
            List<MTFavourite> favourite2UserNew = targetDao._queryMTUser_Favourite2User(userId);
            synchronized (this) {
                if (favourite2User == null) {
                    favourite2User = favourite2UserNew;
                }
            }
        }
        return favourite2User;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetFavourite2User() {
        favourite2User = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTGrain> getGrains2User() {
        if (grains2User == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTGrainDao targetDao = daoSession.getMTGrainDao();
            List<MTGrain> grains2UserNew = targetDao._queryMTUser_Grains2User(userId);
            synchronized (this) {
                if (grains2User == null) {
                    grains2User = grains2UserNew;
                }
            }
        }
        return grains2User;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetGrains2User() {
        grains2User = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTPhoto> getPhoto2User() {
        if (photo2User == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTPhotoDao targetDao = daoSession.getMTPhotoDao();
            List<MTPhoto> photo2UserNew = targetDao._queryMTUser_Photo2User(userId);
            synchronized (this) {
                if (photo2User == null) {
                    photo2User = photo2UserNew;
                }
            }
        }
        return photo2User;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetPhoto2User() {
        photo2User = null;
    }

    /**
     * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
     */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.delete(this);
    }

    /**
     * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
     */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.update(this);
    }

    /**
     * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
     */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
