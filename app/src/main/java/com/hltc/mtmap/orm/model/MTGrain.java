package com.hltc.mtmap.orm.model;

import java.util.List;
import com.hltc.mtmap.orm.DaoSession;
import de.greenrobot.dao.DaoException;

import com.hltc.mtmap.orm.dao.MTCategoryDao;
import com.hltc.mtmap.orm.dao.MTCommentDao;
import com.hltc.mtmap.orm.dao.MTFavouriteDao;
import com.hltc.mtmap.orm.dao.MTGrainDao;
import com.hltc.mtmap.orm.dao.MTPhotoDao;
import com.hltc.mtmap.orm.dao.MTSiteDao;
import com.hltc.mtmap.orm.dao.MTUserDao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table MTGRAIN.
 */
public class MTGrain {

    private long id;
    /** Not-null value. */
    private String description;
    /** Not-null value. */
    private String date;
    private boolean isPublic;
    private boolean isIngored;
    private double latitude;
    private double longitude;
    private long siteId;
    private long categoryId;
    private long userId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient MTGrainDao myDao;

    private MTSite mTSite;
    private Long mTSite__resolvedKey;

    private MTUser mTUser;
    private Long mTUser__resolvedKey;

    private MTCategory mTCategory;
    private Long mTCategory__resolvedKey;

    private List<MTComment> comments2Grain;
    private List<MTFavourite> favourites2Grain;
    private List<MTPhoto> photos2Grain;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public MTGrain() {
    }

    public MTGrain(long id) {
        this.id = id;
    }

    public MTGrain(long id, String description, String date, boolean isPublic, boolean isIngored, double latitude, double longitude, long siteId, long categoryId, long userId) {
        this.id = id;
        this.description = description;
        this.date = date;
        this.isPublic = isPublic;
        this.isIngored = isIngored;
        this.latitude = latitude;
        this.longitude = longitude;
        this.siteId = siteId;
        this.categoryId = categoryId;
        this.userId = userId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMTGrainDao() : null;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /** Not-null value. */
    public String getDescription() {
        return description;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setDescription(String description) {
        this.description = description;
    }

    /** Not-null value. */
    public String getDate() {
        return date;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setDate(String date) {
        this.date = date;
    }

    public boolean getIsPublic() {
        return isPublic;
    }

    public void setIsPublic(boolean isPublic) {
        this.isPublic = isPublic;
    }

    public boolean getIsIngored() {
        return isIngored;
    }

    public void setIsIngored(boolean isIngored) {
        this.isIngored = isIngored;
    }

    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }

    public long getSiteId() {
        return siteId;
    }

    public void setSiteId(long siteId) {
        this.siteId = siteId;
    }

    public long getCategoryId() {
        return categoryId;
    }

    public void setCategoryId(long categoryId) {
        this.categoryId = categoryId;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    /** To-one relationship, resolved on first access. */
    public MTSite getMTSite() {
        long __key = this.siteId;
        if (mTSite__resolvedKey == null || !mTSite__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTSiteDao targetDao = daoSession.getMTSiteDao();
            MTSite mTSiteNew = targetDao.load(__key);
            synchronized (this) {
                mTSite = mTSiteNew;
            	mTSite__resolvedKey = __key;
            }
        }
        return mTSite;
    }

    public void setMTSite(MTSite mTSite) {
        if (mTSite == null) {
            throw new DaoException("To-one property 'siteId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.mTSite = mTSite;
            siteId = mTSite.getId();
            mTSite__resolvedKey = siteId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public MTUser getMTUser() {
        long __key = this.userId;
        if (mTUser__resolvedKey == null || !mTUser__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTUserDao targetDao = daoSession.getMTUserDao();
            MTUser mTUserNew = targetDao.load(__key);
            synchronized (this) {
                mTUser = mTUserNew;
            	mTUser__resolvedKey = __key;
            }
        }
        return mTUser;
    }

    public void setMTUser(MTUser mTUser) {
        if (mTUser == null) {
            throw new DaoException("To-one property 'userId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.mTUser = mTUser;
            userId = mTUser.getUserId();
            mTUser__resolvedKey = userId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public MTCategory getMTCategory() {
        long __key = this.categoryId;
        if (mTCategory__resolvedKey == null || !mTCategory__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTCategoryDao targetDao = daoSession.getMTCategoryDao();
            MTCategory mTCategoryNew = targetDao.load(__key);
            synchronized (this) {
                mTCategory = mTCategoryNew;
            	mTCategory__resolvedKey = __key;
            }
        }
        return mTCategory;
    }

    public void setMTCategory(MTCategory mTCategory) {
        if (mTCategory == null) {
            throw new DaoException("To-one property 'categoryId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.mTCategory = mTCategory;
            categoryId = mTCategory.getId();
            mTCategory__resolvedKey = categoryId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<MTComment> getComments2Grain() {
        if (comments2Grain == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTCommentDao targetDao = daoSession.getMTCommentDao();
            List<MTComment> comments2GrainNew = targetDao._queryMTGrain_Comments2Grain(id);
            synchronized (this) {
                if(comments2Grain == null) {
                    comments2Grain = comments2GrainNew;
                }
            }
        }
        return comments2Grain;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetComments2Grain() {
        comments2Grain = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<MTFavourite> getFavourites2Grain() {
        if (favourites2Grain == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTFavouriteDao targetDao = daoSession.getMTFavouriteDao();
            List<MTFavourite> favourites2GrainNew = targetDao._queryMTGrain_Favourites2Grain(id);
            synchronized (this) {
                if(favourites2Grain == null) {
                    favourites2Grain = favourites2GrainNew;
                }
            }
        }
        return favourites2Grain;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetFavourites2Grain() {
        favourites2Grain = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<MTPhoto> getPhotos2Grain() {
        if (photos2Grain == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTPhotoDao targetDao = daoSession.getMTPhotoDao();
            List<MTPhoto> photos2GrainNew = targetDao._queryMTGrain_Photos2Grain(id);
            synchronized (this) {
                if(photos2Grain == null) {
                    photos2Grain = photos2GrainNew;
                }
            }
        }
        return photos2Grain;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetPhotos2Grain() {
        photos2Grain = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
