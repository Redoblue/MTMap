package com.hltc.mtmap;

import java.util.List;

import com.hltc.mtmap.orm.DaoSession;

import de.greenrobot.dao.DaoException;

import com.hltc.mtmap.orm.MTCategoryDao;
import com.hltc.mtmap.orm.MTCommentDao;
import com.hltc.mtmap.orm.MTFavouriteDao;
import com.hltc.mtmap.orm.MTGrainDao;
import com.hltc.mtmap.orm.MTPhotoDao;
import com.hltc.mtmap.orm.MTSiteDao;
import com.hltc.mtmap.orm.MTUserDao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END

/**
 * Entity mapped to table MTGRAIN.
 */
public class MTGrain {

    private long grainId;
    private String text;
    private String cateId;
    private String createTime;
    private Boolean isPublic;
    /**
     * Not-null value.
     */
    private String siteId;
    private long categoryId;
    private long userId;

    /**
     * Used to resolve relations
     */
    private transient DaoSession daoSession;

    /**
     * Used for active entity operations.
     */
    private transient MTGrainDao myDao;

    private MTSite mTSite;
    private String mTSite__resolvedKey;

    private MTUser mTUser;
    private Long mTUser__resolvedKey;

    private MTCategory mTCategory;
    private Long mTCategory__resolvedKey;

    private List<MTComment> comments2Grain;
    private List<MTFavourite> favourites2Grain;
    private List<MTPhoto> photos2Grain;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public MTGrain() {
    }

    public MTGrain(long grainId) {
        this.grainId = grainId;
    }

    public MTGrain(long grainId, String text, String cateId, String createTime, Boolean isPublic, String siteId, long categoryId, long userId) {
        this.grainId = grainId;
        this.text = text;
        this.cateId = cateId;
        this.createTime = createTime;
        this.isPublic = isPublic;
        this.siteId = siteId;
        this.categoryId = categoryId;
        this.userId = userId;
    }

    /**
     * called by internal mechanisms, do not call yourself.
     */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMTGrainDao() : null;
    }

    public long getGrainId() {
        return grainId;
    }

    public void setGrainId(long grainId) {
        this.grainId = grainId;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getCateId() {
        return cateId;
    }

    public void setCateId(String cateId) {
        this.cateId = cateId;
    }

    public String getCreateTime() {
        return createTime;
    }

    public void setCreateTime(String createTime) {
        this.createTime = createTime;
    }

    public Boolean getIsPublic() {
        return isPublic;
    }

    public void setIsPublic(Boolean isPublic) {
        this.isPublic = isPublic;
    }

    /**
     * Not-null value.
     */
    public String getSiteId() {
        return siteId;
    }

    /**
     * Not-null value; ensure this value is available before it is saved to the database.
     */
    public void setSiteId(String siteId) {
        this.siteId = siteId;
    }

    public long getCategoryId() {
        return categoryId;
    }

    public void setCategoryId(long categoryId) {
        this.categoryId = categoryId;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public MTSite getMTSite() {
        String __key = this.siteId;
        if (mTSite__resolvedKey == null || mTSite__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTSiteDao targetDao = daoSession.getMTSiteDao();
            MTSite mTSiteNew = targetDao.load(__key);
            synchronized (this) {
                mTSite = mTSiteNew;
                mTSite__resolvedKey = __key;
            }
        }
        return mTSite;
    }

    public void setMTSite(MTSite mTSite) {
        if (mTSite == null) {
            throw new DaoException("To-one property 'siteId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.mTSite = mTSite;
            siteId = mTSite.getSiteId();
            mTSite__resolvedKey = siteId;
        }
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public MTUser getMTUser() {
        long __key = this.userId;
        if (mTUser__resolvedKey == null || !mTUser__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTUserDao targetDao = daoSession.getMTUserDao();
            MTUser mTUserNew = targetDao.load(__key);
            synchronized (this) {
                mTUser = mTUserNew;
                mTUser__resolvedKey = __key;
            }
        }
        return mTUser;
    }

    public void setMTUser(MTUser mTUser) {
        if (mTUser == null) {
            throw new DaoException("To-one property 'userId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.mTUser = mTUser;
            userId = mTUser.getUserId();
            mTUser__resolvedKey = userId;
        }
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public MTCategory getMTCategory() {
        long __key = this.categoryId;
        if (mTCategory__resolvedKey == null || !mTCategory__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTCategoryDao targetDao = daoSession.getMTCategoryDao();
            MTCategory mTCategoryNew = targetDao.load(__key);
            synchronized (this) {
                mTCategory = mTCategoryNew;
                mTCategory__resolvedKey = __key;
            }
        }
        return mTCategory;
    }

    public void setMTCategory(MTCategory mTCategory) {
        if (mTCategory == null) {
            throw new DaoException("To-one property 'categoryId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.mTCategory = mTCategory;
            categoryId = mTCategory.getId();
            mTCategory__resolvedKey = categoryId;
        }
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTComment> getComments2Grain() {
        if (comments2Grain == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTCommentDao targetDao = daoSession.getMTCommentDao();
            List<MTComment> comments2GrainNew = targetDao._queryMTGrain_Comments2Grain(grainId);
            synchronized (this) {
                if (comments2Grain == null) {
                    comments2Grain = comments2GrainNew;
                }
            }
        }
        return comments2Grain;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetComments2Grain() {
        comments2Grain = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTFavourite> getFavourites2Grain() {
        if (favourites2Grain == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTFavouriteDao targetDao = daoSession.getMTFavouriteDao();
            List<MTFavourite> favourites2GrainNew = targetDao._queryMTGrain_Favourites2Grain(grainId);
            synchronized (this) {
                if (favourites2Grain == null) {
                    favourites2Grain = favourites2GrainNew;
                }
            }
        }
        return favourites2Grain;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetFavourites2Grain() {
        favourites2Grain = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<MTPhoto> getPhotos2Grain() {
        if (photos2Grain == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MTPhotoDao targetDao = daoSession.getMTPhotoDao();
            List<MTPhoto> photos2GrainNew = targetDao._queryMTGrain_Photos2Grain(grainId);
            synchronized (this) {
                if (photos2Grain == null) {
                    photos2Grain = photos2GrainNew;
                }
            }
        }
        return photos2Grain;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetPhotos2Grain() {
        photos2Grain = null;
    }

    /**
     * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
     */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.delete(this);
    }

    /**
     * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
     */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.update(this);
    }

    /**
     * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
     */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
